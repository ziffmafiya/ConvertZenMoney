import { type Matrix } from 'ml-matrix';
/**
 * Checks whether the solution has converged
 * @param see {@link OptimalityParams} for a description.
 * @returns Pset, Fset, W
 */
export declare function optimality({ iter, maxIter, XtX, XtY, Fset, Pset, W, K, l, p, D, gradientTolerance, }: OptimalityParams): {
    Pset: number[][];
    Fset: number[];
    W: Matrix;
};
/**
 * @param iter - current iteration
 * @param maxIter - maximum number of iterations, @default 3 times the number of columns of X
 * @param XtX - Gram matrix
 * @param XtY
 * @param Fset - Columns to be optimized (active), it stores indices of columns with negative values
 * @param Pset - Subset of matrix K with positive values (indices)
 * @param W - Gradient Matrix
 * @param K - Coefficients Matrix
 * @param l - Number of columns of X
 * @param p - Number of columns of X
 * @param D - K clone
 * @param gradientTolerance - Control over the optimality of the solution; applied over the largest gradient value of all. @default 1e-5.
 */
interface OptimalityParams {
    iter: number;
    Pset: number[][];
    Fset: number[];
    W: Matrix;
    XtX: Matrix;
    XtY: Matrix;
    K: Matrix;
    D: Matrix;
    p: number;
    l: number;
    maxIter: number;
    gradientTolerance: number;
}
export {};
//# sourceMappingURL=optimality.d.ts.map