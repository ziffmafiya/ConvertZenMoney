import { Matrix } from 'ml-matrix';
export interface FcnnlsOptions<T extends boolean | undefined> {
    /**
     * Number of iterations
     * @default 3 times the number of columns of X
     */
    maxIterations?: number;
    /**
     * Larger values (like 1e-4) could help if the number of iterations is exceeded. For most cases, lower values should also be fine.
     * @default 1e-5
     */
    gradientTolerance?: number;
    /**
     * Output the root squared error for each column of Y a well as the matrix K.
     * @default false
     */
    info?: T;
    /**
     * @default true. (The actual value is undefined.) `false` will add a column of ones to the left of X.
     */
    interceptAtZero?: boolean;
}
/**
 * Fast Combinatorial Non-negative Least Squares with multiple Right Hand Side
 * @param X - The data/input/predictors matrix
 * @param Y - The response matrix
 * @param options {@link FcnnlsOptions}
 * @returns By default, the object with the matrix of coefficients K. Please see {@link FcnnlsOutput} for more information.
 */
export declare function fcnnls(X: Matrix | number[][], Y: Matrix | number[] | number[][], options?: FcnnlsOptions<false | undefined>): KOnly;
export declare function fcnnls(X: Matrix | number[][], Y: Matrix | number[] | number[][], options?: FcnnlsOptions<true>): KAndInfo;
export declare function fcnnls<T extends boolean | undefined>(X: Matrix | number[][], Y: Matrix | number[] | number[][], options?: FcnnlsOptions<T>): KAndInfo | KOnly;
export interface Info {
    /**
     * Root Squared Error.
     * This is a row vector, the RSE values for each column of Y.
     */
    rse: number[][];
    /**
     * The number of times K was calculated (it accounts for the OLS guess of `K`, and will be `maxIterations + 1` when maxIterations is reached)
     */
    iterations: number;
}
export type FcnnlsOutput = KAndInfo | KOnly;
export interface KAndInfo {
    K: Matrix;
    info: Info;
}
export interface KOnly {
    K: Matrix;
}
//# sourceMappingURL=fcnnls.d.ts.map