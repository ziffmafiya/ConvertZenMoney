"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.optimality = void 0;
const setDifference_1 = require("./util/setDifference");
/**
 * Checks whether the solution has converged
 * @param see {@link OptimalityParams} for a description.
 * @returns Pset, Fset, W
 */
function optimality({ iter, maxIter, XtX, XtY, Fset, Pset, W, K, l, p, D, gradientTolerance, }) {
    if (iter === maxIter) {
        throw new Error('Maximum number of iterations exceeded. You may try to gradually increase the option.gradientTolerance.');
    }
    // Check solution for optimality
    const V = XtY.subMatrixColumn(Fset).subtract(XtX.mmul(K.subMatrixColumn(Fset)));
    for (let j = 0; j < Fset.length; j++) {
        // for the "negative" columns, we set the new gradient.
        W.setColumn(Fset[j], V.subMatrixColumn([j]));
    }
    const Jset = [];
    const fullSet = [];
    for (let i = 0; i < l; i++) {
        fullSet.push(i);
    }
    for (const colIndex of Fset) {
        const notPset = (0, setDifference_1.setDifference)(fullSet, Pset[colIndex]);
        if (notPset.length === 0) {
            Jset.push(colIndex);
        }
        else if (W.selection(notPset, [colIndex]).max() <= gradientTolerance) {
            Jset.push(colIndex);
        }
    }
    Fset = (0, setDifference_1.setDifference)(Fset, Jset);
    // For non-optimal solutions, add the appropriate variables to Pset
    if (Fset.length !== 0) {
        for (let j = 0; j < Fset.length; j++) {
            for (let i = 0; i < l; i++) {
                if (Pset[Fset[j]].includes(i))
                    W.set(i, Fset[j], -Infinity);
            }
            Pset[Fset[j]].push(W.subMatrixColumn(Fset).maxColumnIndex(j)[0]);
        }
        for (const colIndex of Fset) {
            D.setColumn(colIndex, K.getColumn(colIndex));
        }
    }
    for (let j = 0; j < p; j++) {
        Pset[j].sort((a, b) => a - b);
    }
    return { Pset, Fset, W };
}
exports.optimality = optimality;
//# sourceMappingURL=optimality.js.map