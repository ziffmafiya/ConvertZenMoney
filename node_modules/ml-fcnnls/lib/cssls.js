"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cssls = void 0;
const ml_matrix_1 = require("ml-matrix");
const sortCollectionSet_1 = require("./util/sortCollectionSet");
/**
 * Combinatorial Subspace Least Squares - subfunction for the FC-NNLS
 * Solves XtX*K = XtY for the variables in Pset
 * if XtX (or XtX(vars,vars)) is singular, performs the svd and find pseudo-inverse, otherwise (even if ill-conditioned) finds inverse with LU decomposition and solves the set of equations
 * it is consistent with matlab results for ill-conditioned matrices (at least consistent with test 'ill-conditioned square X rank 2, Y 3x1' in cssls.test)
 * @param Cssls object, @see {@link Cssls}
 */
function cssls({ XtX, XtY, Pset, nColsX, nColsY }) {
    let K = ml_matrix_1.Matrix.zeros(nColsX, nColsY);
    if (Pset === null) {
        // used for initialisation where OLS is solved.
        const choXtX = new ml_matrix_1.CholeskyDecomposition(XtX);
        if (choXtX.isPositiveDefinite()) {
            K = choXtX.solve(XtY);
        }
        else {
            const luXtX = new ml_matrix_1.LuDecomposition(XtX);
            if (!luXtX.isSingular()) {
                K = luXtX.solve(ml_matrix_1.Matrix.eye(nColsX)).mmul(XtY);
            }
            else {
                K = (0, ml_matrix_1.solve)(XtX, XtY, true);
            }
        }
    }
    else {
        const { values: sortedPset, indices: sortedEset } = (0, sortCollectionSet_1.sortCollectionSet)(Pset);
        if (sortedPset.length === 1 &&
            sortedPset[0].length === 0 &&
            sortedEset[0].length === nColsY) {
            return K;
        }
        else if (sortedPset.length === 1 &&
            sortedPset[0].length === nColsX &&
            sortedEset[0].length === nColsY) {
            const choXtX = new ml_matrix_1.CholeskyDecomposition(XtX);
            if (choXtX.isPositiveDefinite()) {
                K = choXtX.solve(XtY);
            }
            else {
                const luXtX = new ml_matrix_1.LuDecomposition(XtX);
                if (!luXtX.isSingular()) {
                    K = luXtX.solve(ml_matrix_1.Matrix.eye(nColsX)).mmul(XtY);
                }
                else {
                    K = (0, ml_matrix_1.solve)(XtX, XtY, true);
                }
            }
        }
        else {
            for (let k = 0; k < sortedPset.length; k++) {
                const cols2Solve = sortedEset[k];
                const vars = sortedPset[k];
                let L;
                const choXtX = new ml_matrix_1.CholeskyDecomposition(XtX.selection(vars, vars));
                if (choXtX.isPositiveDefinite()) {
                    L = choXtX.solve(XtY.selection(vars, cols2Solve));
                }
                else {
                    const luXtX = new ml_matrix_1.LuDecomposition(XtX.selection(vars, vars));
                    if (!luXtX.isSingular()) {
                        L = luXtX
                            .solve(ml_matrix_1.Matrix.eye(vars.length))
                            .mmul(XtY.selection(vars, cols2Solve));
                    }
                    else {
                        L = (0, ml_matrix_1.solve)(XtX.selection(vars, vars), XtY.selection(vars, cols2Solve), true);
                    }
                }
                for (let i = 0; i < L.rows; i++) {
                    for (let j = 0; j < L.columns; j++) {
                        K.set(vars[i], cols2Solve[j], L.get(i, j));
                    }
                }
            }
        }
    }
    return K;
}
exports.cssls = cssls;
//# sourceMappingURL=cssls.js.map