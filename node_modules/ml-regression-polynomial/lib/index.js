"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolynomialRegression = void 0;
const ml_matrix_1 = require("ml-matrix");
const ml_regression_base_1 = require("ml-regression-base");
class PolynomialRegression extends ml_regression_base_1.BaseRegression {
    /**
     * @param x - independent or explanatory variable
     * @param y - dependent or response variable
     * @param degree - degree of the polynomial regression, or array of powers to be used. When degree is an array, intercept at zero is forced to false/ignored.
     * @example `new PolynomialRegression(x, y, 2)`, in this case, you can pass the option `interceptAtZero`, if you need it.
     * @param options
     * @example `new PolynomialRegression(x, y, [1, 3, 5])`
     * Each of the degrees corresponds to a column, so if you have them switched, just do:
     * @example `new PolynomialRegression(x, y, [3, 1, 5])`
     * @param options.interceptAtZero - force the polynomial regression so that f(0) = 0
     */
    constructor(x, y, degree, options = {}) {
        super();
        // @ts-expect-error internal use only
        if (x === true) {
            // @ts-expect-error internal use only
            this.degree = y.degree;
            // @ts-expect-error internal use only
            this.powers = y.powers;
            // @ts-expect-error internal use only
            this.coefficients = y.coefficients;
        }
        else {
            (0, ml_regression_base_1.checkArrayLength)(x, y);
            const result = regress(x, y, degree, options);
            this.degree = result.degree;
            this.powers = result.powers;
            this.coefficients = result.coefficients;
        }
    }
    _predict(x) {
        let y = 0;
        for (let k = 0; k < this.powers.length; k++) {
            y += this.coefficients[k] * x ** this.powers[k];
        }
        return y;
    }
    toJSON() {
        return {
            name: 'polynomialRegression',
            degree: this.degree,
            powers: this.powers,
            coefficients: this.coefficients,
        };
    }
    toString(precision) {
        return this._toFormula(precision, false);
    }
    toLaTeX(precision) {
        return this._toFormula(precision, true);
    }
    _toFormula(precision, isLaTeX) {
        let sup = '^';
        let closeSup = '';
        let times = ' * ';
        if (isLaTeX) {
            sup = '^{';
            closeSup = '}';
            times = '';
        }
        let fn = '';
        let str = '';
        for (let k = 0; k < this.coefficients.length; k++) {
            str = '';
            if (this.coefficients[k] !== 0) {
                if (this.powers[k] === 0) {
                    str = (0, ml_regression_base_1.maybeToPrecision)(this.coefficients[k], precision);
                }
                else if (this.powers[k] === 1) {
                    str = `${(0, ml_regression_base_1.maybeToPrecision)(this.coefficients[k], precision) + times}x`;
                }
                else {
                    str = `${(0, ml_regression_base_1.maybeToPrecision)(this.coefficients[k], precision) + times}x${sup}${this.powers[k]}${closeSup}`;
                }
                if (this.coefficients[k] > 0 && k !== this.coefficients.length - 1) {
                    str = ` + ${str}`;
                }
                else if (k !== this.coefficients.length - 1) {
                    str = ` ${str}`;
                }
            }
            fn = str + fn;
        }
        if (fn.startsWith('+')) {
            fn = fn.slice(1);
        }
        return `f(x) = ${fn}`;
    }
    static load(json) {
        if (json.name !== 'polynomialRegression') {
            throw new TypeError('not a polynomial regression model');
        }
        // @ts-expect-error internal use only
        return new PolynomialRegression(true, json);
    }
}
exports.PolynomialRegression = PolynomialRegression;
/**
 * Perform a polynomial regression on the given data set.
 * This is an internal function.
 * @param x - independent or explanatory variable
 * @param y - dependent or response variable
 * @param degree - degree of the polynomial regression
 * @param options.interceptAtZero - force the polynomial regression so that $f(0) = 0$
 * @param options
 */
function regress(x, y, degree, options = {}) {
    const n = x.length;
    let { interceptAtZero = false } = options;
    let powers = [];
    if (Array.isArray(degree)) {
        powers = degree;
        interceptAtZero = false; //must be false in this case
    }
    else if (typeof degree === 'number') {
        if (interceptAtZero) {
            powers = new Array(degree);
            for (let k = 0; k < degree; k++) {
                powers[k] = k + 1;
            }
        }
        else {
            powers = new Array(degree + 1);
            for (let k = 0; k <= degree; k++) {
                powers[k] = k;
            }
        }
    }
    const nCoefficients = powers.length; //1 per power, in any case.
    const F = new ml_matrix_1.Matrix(n, nCoefficients);
    const Y = new ml_matrix_1.Matrix([y]);
    for (let k = 0; k < nCoefficients; k++) {
        for (let i = 0; i < n; i++) {
            if (powers[k] === 0) {
                F.set(i, k, 1);
            }
            else {
                F.set(i, k, x[i] ** powers[k]);
            }
        }
    }
    const FT = new ml_matrix_1.MatrixTransposeView(F);
    const A = FT.mmul(F);
    const B = FT.mmul(new ml_matrix_1.MatrixTransposeView(Y));
    return {
        coefficients: (0, ml_matrix_1.solve)(A, B).to1DArray(),
        degree: Math.max(...powers),
        powers,
    };
}
//# sourceMappingURL=index.js.map