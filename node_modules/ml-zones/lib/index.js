'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Normalize an array of zones:
 * - ensure than from < to
 * - merge overlapping zones
 *
 * The method will always check if from if lower than to and will swap if required.
 * @param {Array} [zones=[]]
 * @param {object} [options={}]
 * @param {number} [options.from=Number.NEGATIVE_INFINITY] Specify min value of a zone
 * @param {number} [options.to=Number.POSITIVE_INFINITY] Specify max value of a zone
 */

function normalize(zones = [], options = {}) {
  if (zones.length === 0) return [];
  let {
    from = Number.NEGATIVE_INFINITY,
    to = Number.POSITIVE_INFINITY,
  } = options;
  if (from > to) [from, to] = [to, from];

  zones = JSON.parse(JSON.stringify(zones)).map((zone) =>
    zone.from > zone.to ? { from: zone.to, to: zone.from } : zone,
  );
  zones = zones.sort((a, b) => {
    if (a.from !== b.from) return a.from - b.from;
    return a.to - b.to;
  });

  zones.forEach((zone) => {
    if (from > zone.from) zone.from = from;
    if (to < zone.to) zone.to = to;
  });

  zones = zones.filter((zone) => zone.from <= zone.to);
  if (zones.length === 0) return [];

  let currentZone = zones[0];
  let result = [currentZone];
  for (let i = 1; i < zones.length; i++) {
    let zone = zones[i];
    if (zone.from <= currentZone.to) {
      currentZone.to = zone.to;
    } else {
      currentZone = zone;
      result.push(currentZone);
    }
  }
  return result;
}

/**
 * Convert an array of exclusions and keep only from / to
 *
 * The method will always check if from if lower than to and will swap if required.
 * @param {Array} [exclusions=[]]
 * @param {object} [options={}]
 * @param {number} [options.from=Number.NEGATIVE_INFINITY] Specify min value of zones (after inversion)
 * @param {number} [options.to=Number.POSITIVE_INFINITY] Specify max value of zones (after inversion)
 */

function invert(exclusions = [], options = {}) {
  let {
    from = Number.NEGATIVE_INFINITY,
    to = Number.POSITIVE_INFINITY,
  } = options;
  if (from > to) [from, to] = [to, from];

  exclusions = normalize(exclusions, { from, to });
  if (exclusions.length === 0) return [{ from, to }];

  let zones = [];
  for (let i = 0; i < exclusions.length; i++) {
    let exclusion = exclusions[i];
    let nextExclusion = exclusions[i + 1];
    if (i === 0) {
      if (exclusion.from > from) {
        zones.push({ from, to: exclusion.from });
      }
    }
    if (i === exclusions.length - 1) {
      if (exclusion.to < to) {
        zones.push({ from: exclusion.to, to });
      }
    } else {
      zones.push({ from: exclusion.to, to: nextExclusion.from });
    }
  }

  return zones;
}

/**
 * Add the number of points per zone to reach a specified total
 * @param {Array} [zones=[]]
 * @param {number} [numberOfPoints] Total number of points to distribute between zones
 * @param {object} [options={}]
 * @param {number} [options.from=Number.NEGATIVE_INFINITY] Specify min value of a zone
 * @param {number} [options.to=Number.POSITIVE_INFINITY] Specify max value of a zone
 */

function zonesWithPoints(zones, numberOfPoints, options = {}) {
  if (zones.length === 0) return zones;
  zones = normalize(zones, options);

  const totalSize = zones.reduce((previous, current) => {
    return previous + (current.to - current.from);
  }, 0);

  let unitsPerPoint = totalSize / numberOfPoints;
  let currentTotal = 0;
  for (let i = 0; i < zones.length - 1; i++) {
    let zone = zones[i];
    zone.numberOfPoints = Math.min(
      Math.round((zone.to - zone.from) / unitsPerPoint),
      numberOfPoints - currentTotal,
    );
    currentTotal += zone.numberOfPoints;
  }

  zones[zones.length - 1].numberOfPoints = numberOfPoints - currentTotal;

  return zones;
}

exports.invert = invert;
exports.normalize = normalize;
exports.zonesWithPoints = zonesWithPoints;
