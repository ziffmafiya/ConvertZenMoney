import { isAnyArray } from 'is-any-array';
import { BaseRegression, checkArrayLength, maybeToPrecision, } from 'ml-regression-base';
import { predict } from './utilities/predict';
import { robustPolynomial } from './utilities/robustPolynomial';
/**
 * @class RobustPolynomialRegression
 * @param x
 * @param y
 * @param degree - polynomial degree
 */
export class RobustPolynomialRegression extends BaseRegression {
    constructor(x, y, degree) {
        super();
        if (isAnyArray(x)) {
            checkArrayLength(x, y);
            robustPolynomial(this, x, y, degree);
        }
        else {
            const name = 'robustPolynomialRegression';
            const model = x;
            this.degree = model.degree;
            this.powers = model.powers;
            this.coefficients = model.coefficients;
            this.name = name;
        }
    }
    toJSON() {
        return {
            name: this.name,
            degree: this.degree,
            powers: this.powers,
            coefficients: this.coefficients,
        };
    }
    _predict(x) {
        return predict(x, this.powers, this.coefficients);
    }
    /**
     * Display the formula
     * @param precision - precision for the numbers
     * @returns
     */
    toString(precision) {
        return this._toFormula(precision, false);
    }
    /**
     * Display the formula in LaTeX format
     * @param precision - precision for the numbers
     * @returns
     */
    toLaTeX(precision) {
        return this._toFormula(precision, true);
    }
    _toFormula(precision, isLaTeX) {
        let sup = '^';
        let closeSup = '';
        let times = ' * ';
        if (isLaTeX) {
            sup = '^{';
            closeSup = '}';
            times = '';
        }
        let fn = '';
        let str = '';
        const coefficients = this.coefficients;
        const powers = this.powers;
        for (let k = 0; k < coefficients.length; k++) {
            str = '';
            if (coefficients[k] !== 0) {
                if (powers[k] === 0) {
                    str = maybeToPrecision(coefficients[k], precision);
                }
                else if (powers[k] === 1) {
                    str = `${maybeToPrecision(coefficients[k], precision) + times}x`;
                }
                else {
                    str = `${maybeToPrecision(coefficients[k], precision) + times}x${sup}${powers[k]}${closeSup}`;
                }
                if (coefficients[k] > 0 && k !== coefficients.length - 1) {
                    str = ` + ${str}`;
                }
                else if (k !== coefficients.length - 1) {
                    str = ` ${str}`;
                }
            }
            fn = str + fn;
        }
        if (fn.startsWith('+')) {
            fn = fn.slice(1);
        }
        return `f(x) = ${fn}`;
    }
    static load(json) {
        if (json.name !== 'robustPolynomialRegression') {
            throw new TypeError('not a RobustPolynomialRegression model');
        }
        return new RobustPolynomialRegression(json, undefined, undefined);
    }
}
//# sourceMappingURL=index.js.map