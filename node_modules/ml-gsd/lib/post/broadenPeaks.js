"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.broadenPeaks = broadenPeaks;
const ml_peak_shape_generator_1 = require("ml-peak-shape-generator");
/**
 * This method will allow to enlarge peaks while preventing overlap between peaks
 * A typical application in chromatography peak picking.
 * We should not make the hypothesis that x is equidistant
 * Because peaks may not be symmetric after we add 2 properties, from and to.
 * @return {Array} peakList
 */
function broadenPeaks(peakList, options = {}) {
    const { factor = 2, overlap = false } = options;
    const peaks = mapPeaks(peakList, factor);
    if (!overlap) {
        for (let i = 0; i < peaks.length - 1; i++) {
            const peak = peaks[i];
            const nextPeak = peaks[i + 1];
            if (peak.to.x > nextPeak.from.x) {
                // we do it proportional to the width of the peaks
                peak.to.x =
                    (peak.width / (nextPeak.width + peak.width)) * (nextPeak.x - peak.x) +
                        peak.x;
                nextPeak.from.x = peak.to.x;
            }
        }
    }
    for (const peak of peaks) {
        peak.width = peak.to.x - peak.from.x;
        if (peak.shape) {
            const { shape, width } = peak;
            if (shape.fwhm !== undefined) {
                const shapeFct = (0, ml_peak_shape_generator_1.getShape1D)(shape);
                peak.shape.fwhm = shapeFct.widthToFWHM(width);
            }
        }
    }
    return peaks;
}
function mapPeaks(peaks, factor) {
    return peaks.map((peak) => {
        const { id, shape } = peak;
        const xFrom = peak.x - (peak.x - peak.inflectionPoints.from.x) * factor;
        const xTo = peak.x + (peak.inflectionPoints.to.x - peak.x) * factor;
        let result = {
            x: peak.x,
            y: peak.y,
            index: peak.index,
            width: xTo - xFrom,
            from: { x: xFrom },
            to: { x: xTo },
        };
        if (id) {
            result = { ...result, id };
        }
        if (shape) {
            result = { ...result, shape };
        }
        return result;
    });
}
//# sourceMappingURL=broadenPeaks.js.map