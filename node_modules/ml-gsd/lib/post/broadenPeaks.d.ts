import { Shape1D } from 'ml-peak-shape-generator';
import { GSDBroadenPeak } from '../GSDBroadenPeak';
import { GSDPeak } from '../GSDPeak';
type GSDPeakOptionalShape = GSDPeak & {
    shape?: Shape1D;
};
type GSDBroadenPeakWithID = GSDBroadenPeak & {
    id: string;
};
type GSDBroadenPeakWithShape = GSDBroadenPeak & {
    shape: Shape1D;
};
type GSDBroadenPeakWithShapeID = GSDBroadenPeakWithID & {
    shape: Shape1D;
};
export type WithOrWithout<T, ToExtends, TrueType, FalseType> = T extends ToExtends ? TrueType : FalseType;
export type WithIDOrShape<T> = T extends {
    id: string;
} ? WithOrWithout<T, GSDPeak, GSDBroadenPeakWithShapeID, GSDBroadenPeakWithID> : WithOrWithout<T, GSDPeak, GSDBroadenPeakWithShape, GSDBroadenPeak>;
/**
 * This method will allow to enlarge peaks while preventing overlap between peaks
 * A typical application in chromatography peak picking.
 * We should not make the hypothesis that x is equidistant
 * Because peaks may not be symmetric after we add 2 properties, from and to.
 * @return {Array} peakList
 */
export declare function broadenPeaks<T extends GSDPeakOptionalShape>(peakList: T[], options?: {
    /**
     * @default 2
     */
    factor?: number;
    /**
     * by default we don't allow overlap
     * @default false
     */
    overlap?: boolean;
}): WithIDOrShape<T>[];
export {};
//# sourceMappingURL=broadenPeaks.d.ts.map