"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recursiveCheck = void 0;
const utils_1 = require("./utils");
function cmpNumber(received, expected, precision) {
    if (isNaN(received)) {
        return isNaN(expected) ? false : { reason: 'Expected', expected, received };
    }
    if (!isFinite(received)) {
        return received === expected
            ? false
            : { reason: 'Expected', expected, received };
    }
    if (Math.abs(received - expected) <= (0, utils_1.calculatePrecision)(precision)) {
        return false;
    }
    return {
        reason: 'Expected',
        expected,
        received,
        diff: Math.abs(received - expected),
    };
}
function cmpEqual(received, expected) {
    if (received === expected)
        return false;
    return {
        reason: `The ${typeof expected}s do not match`,
        expected,
        received,
    };
}
function cmpArray(received, expected, precision, strict) {
    const receivedLength = received.length;
    const expectedLength = expected.length;
    if (receivedLength !== expectedLength) {
        return {
            reason: 'The arrays length does not match',
            expected: expectedLength,
            received: receivedLength,
        };
    }
    for (let i = 0; i < receivedLength; i++) {
        const error = recursiveCheck(received[i], expected[i], precision, strict);
        if (error) {
            return { ...error, index: i };
        }
    }
    return false;
}
function cmpObject(received, expected, precision, strict) {
    const sorter = (a, b) => a.localeCompare(b);
    const receivedKeys = Object.keys(received).sort(sorter);
    const expectedKeys = Object.keys(expected).sort(sorter);
    const sameLength = !strict || receivedKeys.length === expectedKeys.length;
    if (!sameLength ||
        expectedKeys.some((e) => !Object.prototype.hasOwnProperty.call(received, e))) {
        return {
            reason: 'The objects do not have similar keys',
            expected: expectedKeys,
            received: receivedKeys,
        };
    }
    for (const prop in expected) {
        const propError = recursiveCheck(received[prop], expected[prop], precision, strict);
        if (propError)
            return { ...propError, key: prop };
    }
    return false;
}
/**
 * @param {number|Array} received
 * @param {number|Array} expected
 * @param {number} precision
 * @param {boolean} strict equality or subsets allowed
 * @return {boolean|{reason, expected, received}}
 */
function recursiveCheck(received, expected, precision, strict = true) {
    // Received and expected are numbers
    if (typeof received === 'number' && typeof expected === 'number') {
        return cmpNumber(received, expected, precision);
    }
    if ((typeof received === 'string' && typeof expected === 'string') ||
        (typeof received === 'boolean' && typeof expected === 'boolean')) {
        return cmpEqual(received, expected);
    }
    // Received and expected are arrays
    if (isArray(received) && isArray(expected)) {
        return cmpArray(received, expected, precision, strict);
    }
    /* Received and expected are either
     * 1) both explicitly set as undefined
     * 2) undefined properties of an object, where the received value may be implicitly undefined
     */
    if (expected === undefined && received === undefined)
        return false;
    // Received and expected are null
    if (expected === null && received === null)
        return false;
    // Received and expected are objects
    if (expected !== null &&
        typeof expected === 'object' &&
        !Array.isArray(received) &&
        received !== null &&
        typeof received === 'object' &&
        !Array.isArray(expected)) {
        return cmpObject(received, expected, precision, strict);
    }
    // Error for all other types
    return {
        reason: 'The current data type is not supported or they do not match',
        expected: typeof expected,
        received: typeof received,
    };
}
exports.recursiveCheck = recursiveCheck;
function isArray(value) {
    return (Array.isArray(value) ||
        value instanceof Float32Array ||
        value instanceof Float64Array);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJzaXZlQ2hlY2suanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvcmVjdXJzaXZlQ2hlY2sudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsbUNBQTZDO0FBSTdDLFNBQVMsU0FBUyxDQUNoQixRQUFnQixFQUNoQixRQUFnQixFQUNoQixTQUFpQjtJQUVqQixJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUNuQixPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDO0tBQzdFO0lBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUN2QixPQUFPLFFBQVEsS0FBSyxRQUFRO1lBQzFCLENBQUMsQ0FBQyxLQUFLO1lBQ1AsQ0FBQyxDQUFDLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUM7S0FDaEQ7SUFFRCxJQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxJQUFJLElBQUEsMEJBQWtCLEVBQUMsU0FBUyxDQUFDLEVBQUU7UUFDbEUsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELE9BQU87UUFDTCxNQUFNLEVBQUUsVUFBVTtRQUNsQixRQUFRO1FBQ1IsUUFBUTtRQUNSLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7S0FDcEMsQ0FBQztBQUNKLENBQUM7QUFFRCxTQUFTLFFBQVEsQ0FBSSxRQUFXLEVBQUUsUUFBVztJQUMzQyxJQUFJLFFBQVEsS0FBSyxRQUFRO1FBQUUsT0FBTyxLQUFLLENBQUM7SUFFeEMsT0FBTztRQUNMLE1BQU0sRUFBRSxPQUFPLE9BQU8sUUFBUSxnQkFBZ0I7UUFDOUMsUUFBUTtRQUNSLFFBQVE7S0FDVCxDQUFD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