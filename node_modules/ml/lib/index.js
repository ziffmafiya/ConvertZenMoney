'use strict';

var mlPca = require('ml-pca');
var mlKnn = require('ml-knn');
var mlPls = require('ml-pls');
var mlConfusionMatrix = require('ml-confusion-matrix');
var mlFnn = require('ml-fnn');
var mlSom = require('ml-som');
var mlRegression = require('ml-regression');
var mlLevenbergMarquardt = require('ml-levenberg-marquardt');
var MatrixLib = require('ml-matrix');
var mlSparseMatrix = require('ml-sparse-matrix');
var mlKernel = require('ml-kernel');
var mlDistance = require('ml-distance');
var mlDistanceMatrix = require('ml-distance-matrix');
var mlXsadd = require('ml-xsadd');
var mlNgmca = require('ml-ngmca');
var mlPerformance = require('ml-performance');
var mlSavitzkyGolay = require('ml-savitzky-golay');
var mlBitArray = require('ml-bit-array');
var mlHashTable = require('ml-hash-table');
var mlPadArray = require('ml-pad-array');
var binarySearch = require('binary-search');
var mlRandom = require('ml-random');
var min = require('ml-array-min');
var max = require('ml-array-max');
var median = require('ml-array-median');
var mean = require('ml-array-mean');
var mode = require('ml-array-mode');
var normed = require('ml-array-normed');
var rescale = require('ml-array-rescale');
var sequentialFill = require('ml-array-sequential-fill');
var sum = require('ml-array-sum');
var standardDeviation = require('ml-array-standard-deviation');
var variance = require('ml-array-variance');
var centroidsMerge = require('ml-array-xy-centroids-merge');
var closestX = require('ml-arrayxy-closestx');
var covariance = require('ml-array-xy-covariance');
var maxMerge = require('ml-array-xy-max-merge');
var maxY = require('ml-array-xy-max-y');
var sortX = require('ml-array-xy-sort-x');
var uniqueX = require('ml-arrayxy-uniquex');
var weightedMerge = require('ml-array-xy-weighted-merge');
var equallySpaced = require('ml-array-xy-equally-spaced');
var filterX = require('ml-array-xy-filter-x');
var mlCart = require('ml-cart');
var mlRandomForest = require('ml-random-forest');
var mlHclust = require('ml-hclust');
var mlKmeans = require('ml-kmeans');
var mlNaivebayes = require('ml-naivebayes');
var mlCrossValidation = require('ml-cross-validation');
var mlFcnnls = require('ml-fcnnls');
var mlGsd = require('ml-gsd');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var MatrixLib__namespace = /*#__PURE__*/_interopNamespaceDefault(MatrixLib);
var mlHclust__namespace = /*#__PURE__*/_interopNamespaceDefault(mlHclust);
var mlKmeans__namespace = /*#__PURE__*/_interopNamespaceDefault(mlKmeans);
var mlNaivebayes__namespace = /*#__PURE__*/_interopNamespaceDefault(mlNaivebayes);
var mlCrossValidation__namespace = /*#__PURE__*/_interopNamespaceDefault(mlCrossValidation);
var mlFcnnls__namespace = /*#__PURE__*/_interopNamespaceDefault(mlFcnnls);
var mlGsd__namespace = /*#__PURE__*/_interopNamespaceDefault(mlGsd);

/* eslint-disable import/newline-after-import */
/* eslint-disable import/order */
/* eslint-disable import/first */

const {
  Matrix,
  SVD,
  EVD,
  CholeskyDecomposition,
  LuDecomposition,
  QrDecomposition,
} = MatrixLib__namespace;
const Array = {
  min,
  max,
  median,
  mean,
  mode,
  normed,
  rescale,
  sequentialFill,
  standardDeviation,
  sum,
  variance,
};
const ArrayXY = {
  centroidsMerge,
  closestX,
  covariance,
  maxMerge,
  maxY,
  sortX,
  uniqueX,
  weightedMerge,
  equallySpaced,
  filterX,
};

Object.defineProperty(exports, "PCA", {
  enumerable: true,
  get: function () { return mlPca.PCA; }
});
exports.KNN = mlKnn;
Object.defineProperty(exports, "KOPLS", {
  enumerable: true,
  get: function () { return mlPls.KOPLS; }
});
Object.defineProperty(exports, "OPLS", {
  enumerable: true,
  get: function () { return mlPls.OPLS; }
});
Object.defineProperty(exports, "PLS", {
  enumerable: true,
  get: function () { return mlPls.PLS; }
});
Object.defineProperty(exports, "oplsNipals", {
  enumerable: true,
  get: function () { return mlPls.oplsNipals; }
});
Object.defineProperty(exports, "ConfusionMatrix", {
  enumerable: true,
  get: function () { return mlConfusionMatrix.ConfusionMatrix; }
});
exports.FNN = mlFnn;
exports.SOM = mlSom;
Object.defineProperty(exports, "ExponentialRegression", {
  enumerable: true,
  get: function () { return mlRegression.ExponentialRegression; }
});
Object.defineProperty(exports, "MultivariateLinearRegression", {
  enumerable: true,
  get: function () { return mlRegression.MultivariateLinearRegression; }
});
Object.defineProperty(exports, "PolynomialRegression", {
  enumerable: true,
  get: function () { return mlRegression.PolynomialRegression; }
});
Object.defineProperty(exports, "PowerRegression", {
  enumerable: true,
  get: function () { return mlRegression.PowerRegression; }
});
Object.defineProperty(exports, "RobustPolynomialRegression", {
  enumerable: true,
  get: function () { return mlRegression.RobustPolynomialRegression; }
});
Object.defineProperty(exports, "SimpleLinearRegression", {
  enumerable: true,
  get: function () { return mlRegression.SimpleLinearRegression; }
});
Object.defineProperty(exports, "TheilSenRegression", {
  enumerable: true,
  get: function () { return mlRegression.TheilSenRegression; }
});
Object.defineProperty(exports, "levenbergMarquardt", {
  enumerable: true,
  get: function () { return mlLevenbergMarquardt.levenbergMarquardt; }
});
exports.MatrixLib = MatrixLib__namespace;
Object.defineProperty(exports, "SparseMatrix", {
  enumerable: true,
  get: function () { return mlSparseMatrix.SparseMatrix; }
});
exports.Kernel = mlKernel;
Object.defineProperty(exports, "Distance", {
  enumerable: true,
  get: function () { return mlDistance.distance; }
});
Object.defineProperty(exports, "Similarity", {
  enumerable: true,
  get: function () { return mlDistance.similarity; }
});
exports.distanceMatrix = mlDistanceMatrix;
Object.defineProperty(exports, "XSadd", {
  enumerable: true,
  get: function () { return mlXsadd.XSadd; }
});
Object.defineProperty(exports, "nGMCA", {
  enumerable: true,
  get: function () { return mlNgmca.nGMCA; }
});
exports.Performance = mlPerformance;
exports.savitzkyGolay = mlSavitzkyGolay;
exports.BitArray = mlBitArray;
exports.HashTable = mlHashTable;
exports.padArray = mlPadArray;
exports.binarySearch = binarySearch;
Object.defineProperty(exports, "Random", {
  enumerable: true,
  get: function () { return mlRandom.Random; }
});
Object.defineProperty(exports, "DecisionTreeClassifier", {
  enumerable: true,
  get: function () { return mlCart.DecisionTreeClassifier; }
});
Object.defineProperty(exports, "DecisionTreeRegression", {
  enumerable: true,
  get: function () { return mlCart.DecisionTreeRegression; }
});
Object.defineProperty(exports, "RandomForestClassifier", {
  enumerable: true,
  get: function () { return mlRandomForest.RandomForestClassifier; }
});
Object.defineProperty(exports, "RandomForestRegression", {
  enumerable: true,
  get: function () { return mlRandomForest.RandomForestRegression; }
});
exports.HClust = mlHclust__namespace;
exports.KMeans = mlKmeans__namespace;
exports.NaiveBayes = mlNaivebayes__namespace;
exports.CrossValidation = mlCrossValidation__namespace;
exports.FCNNLS = mlFcnnls__namespace;
exports.GSD = mlGsd__namespace;
exports.Array = Array;
exports.ArrayXY = ArrayXY;
exports.CholeskyDecomposition = CholeskyDecomposition;
exports.EVD = EVD;
exports.LuDecomposition = LuDecomposition;
exports.Matrix = Matrix;
exports.QrDecomposition = QrDecomposition;
exports.SVD = SVD;
