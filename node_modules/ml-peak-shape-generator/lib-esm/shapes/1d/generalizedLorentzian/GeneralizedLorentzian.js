import { ROOT_THREE } from '../../../util/constants';
/**
 * This shape is a linear combination of rational function (n|n+2), for n = 0 (lorentzian function) and n = 2
 * the parameter that combines those two functions is `gamma` and it is called the kurtosis parameter, it is an
 * implementation of generalized lorentzian shape published by Stanislav Sykora in the SMASH 2010. DOI:10.3247/SL3nmr10.006
 * @link http://www.ebyte.it/stan/Talk_ML_UserMeeting_SMASH_2010_GeneralizedLorentzian.html
 */
export class GeneralizedLorentzian {
    constructor(options = {}) {
        const { fwhm = 500, gamma = 0.5 } = options;
        this.fwhm = fwhm;
        this.gamma = gamma;
    }
    fwhmToWidth(fwhm = this.fwhm) {
        return generalizedLorentzianFwhmToWidth(fwhm);
    }
    widthToFWHM(width) {
        return generalizedLorentzianWidthToFWHM(width);
    }
    fct(x) {
        return generalizedLorentzianFct(x, this.fwhm, this.gamma);
    }
    getArea(height = 1) {
        return getGeneralizedLorentzianArea({
            fwhm: this.fwhm,
            height,
            gamma: this.gamma,
        });
    }
    getFactor(area) {
        return getGeneralizedLorentzianFactor(area);
    }
    getData(options = {}) {
        return getGeneralizedLorentzianData(this, options);
    }
    calculateHeight(area = 1) {
        const { gamma, fwhm } = this;
        return calculateGeneralizedLorentzianHeight({ fwhm, area, gamma });
    }
    getParameters() {
        return ['fwhm', 'gamma'];
    }
}
export const calculateGeneralizedLorentzianHeight = ({ fwhm = 1, gamma = 1, area = 1, }) => {
    return (area / fwhm / (3.14159 - 0.420894 * gamma)) * 2;
};
/**
 * expression of integral generated by Mathematica of the function
 */
export const getGeneralizedLorentzianArea = (options) => {
    const { fwhm = 500, height = 1, gamma = 1 } = options;
    return (height * fwhm * (3.14159 - 0.420894 * gamma)) / 2;
};
export const generalizedLorentzianFct = (x, fwhm, gamma) => {
    const u = ((2 * x) / fwhm) ** 2;
    return (1 - gamma) / (1 + u) + (gamma * (1 + u / 2)) / (1 + u + u ** 2);
};
export const generalizedLorentzianWidthToFWHM = (width) => {
    return width * ROOT_THREE;
};
export const generalizedLorentzianFwhmToWidth = (fwhm) => {
    return fwhm / ROOT_THREE;
};
export const getGeneralizedLorentzianFactor = (area = 0.9999) => {
    if (area >= 1) {
        throw new Error('area should be (0 - 1)');
    }
    const halfResidual = (1 - area) * 0.5;
    const quantileFunction = (p) => Math.tan(Math.PI * (p - 0.5));
    return ((quantileFunction(1 - halfResidual) - quantileFunction(halfResidual)) / 2);
};
export const getGeneralizedLorentzianData = (shape = {}, options = {}) => {
    let { fwhm = 500, gamma = 1 } = shape;
    let { length, factor = getGeneralizedLorentzianFactor(), height = calculateGeneralizedLorentzianHeight({ fwhm, area: 1, gamma }), } = options;
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = generalizedLorentzianFct(i - center, fwhm, gamma) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
};
//# sourceMappingURL=GeneralizedLorentzian.js.map