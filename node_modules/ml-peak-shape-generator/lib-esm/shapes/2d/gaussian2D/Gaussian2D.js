import { GAUSSIAN_EXP_FACTOR } from '../../../util/constants';
import { getGaussianFactor, gaussianFwhmToWidth, gaussianWidthToFWHM, } from '../../1d/gaussian/Gaussian';
export class Gaussian2D {
    constructor(options = {}) {
        let { fwhm = 20, sd } = options;
        fwhm = ensureFWHM2D(fwhm, sd);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
    fct(x, y) {
        return gaussian2DFct(x, y, this.fwhmX, this.fwhmY);
    }
    getData(options = {}) {
        return getGaussian2DData({
            fwhm: { x: this.fwhmX, y: this.fwhmY },
        }, options);
    }
    getFactor(volume = 1) {
        return getGaussianFactor(volume);
    }
    getVolume(height = calculateGaussian2DHeight({
        fwhm: { x: this.fwhmX, y: this.fwhmY },
        volume: 1,
    })) {
        return getGaussian2DVolume({
            fwhm: { x: this.fwhmX, y: this.fwhmY },
            height,
        });
    }
    widthToFWHM(width) {
        return gaussianWidthToFWHM(width);
    }
    fwhmToWidth(fwhm) {
        return gaussianFwhmToWidth(fwhm);
    }
    calculateHeight(volume = 1) {
        return calculateGaussian2DHeight({
            volume,
            fwhm: { x: this.fwhmX, y: this.fwhmY },
        });
    }
    set fwhm(fwhm) {
        fwhm = ensureXYNumber(fwhm);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
}
export const gaussian2DFct = (x, y, xFWHM, yFWHM) => {
    return Math.exp(GAUSSIAN_EXP_FACTOR * (Math.pow(x / xFWHM, 2) + Math.pow(y / yFWHM, 2)));
};
export const getGaussian2DData = (shape, options = {}) => {
    let { fwhm = 50, sd } = shape;
    fwhm = ensureFWHM2D(fwhm, sd);
    let { factor = getGaussianFactor(), length = { x: 0, y: 0 }, height = calculateGaussian2DHeight({ fwhm, volume: 1 }), } = options;
    factor = ensureXYNumber(factor);
    length = ensureXYNumber(length);
    for (const axis of ['x', 'y']) {
        if (!length[axis]) {
            length[axis] = Math.min(Math.ceil(fwhm[axis] * factor[axis]), Math.pow(2, 25) - 1);
            if (length[axis] % 2 === 0)
                length[axis]++;
        }
    }
    const xCenter = (length.x - 1) / 2;
    const yCenter = (length.y - 1) / 2;
    const data = new Array(length.x);
    for (let i = 0; i < length.x; i++) {
        data[i] = new Float64Array(length.y);
    }
    for (let i = 0; i < length.x; i++) {
        for (let j = 0; j < length.y; j++) {
            data[i][j] =
                gaussian2DFct(i - xCenter, j - yCenter, fwhm.x, fwhm.y) * height;
        }
    }
    return data;
};
export const calculateGaussian2DHeight = (options = {}) => {
    let { volume = 1, fwhm = 50, sd } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    return (volume * Math.LN2 * 4) / (Math.PI * fwhm.y * fwhm.x);
};
export const getGaussian2DVolume = (options = {}) => {
    let { fwhm = 50, height = 1, sd } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    return (height * Math.PI * fwhm.y * fwhm.x) / Math.LN2 / 4;
};
function ensureXYNumber(input) {
    return typeof input !== 'object' ? { x: input, y: input } : { ...input };
}
function ensureFWHM2D(fwhm, sd) {
    if (sd !== undefined) {
        let sdObject = ensureXYNumber(sd);
        return {
            x: gaussianWidthToFWHM(2 * sdObject.x),
            y: gaussianWidthToFWHM(2 * sdObject.y),
        };
    }
    else if (fwhm !== undefined) {
        return ensureXYNumber(fwhm);
    }
    else {
        throw new Error('ensureFWHM2D must have either fwhm or sd defined');
    }
}
//# sourceMappingURL=Gaussian2D.js.map