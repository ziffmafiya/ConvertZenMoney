"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGaussian2DVolume = exports.calculateGaussian2DHeight = exports.getGaussian2DData = exports.gaussian2DFct = exports.Gaussian2D = void 0;
const constants_1 = require("../../../util/constants");
const Gaussian_1 = require("../../1d/gaussian/Gaussian");
class Gaussian2D {
    constructor(options = {}) {
        let { fwhm = 20, sd } = options;
        fwhm = ensureFWHM2D(fwhm, sd);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
    fct(x, y) {
        return (0, exports.gaussian2DFct)(x, y, this.fwhmX, this.fwhmY);
    }
    getData(options = {}) {
        return (0, exports.getGaussian2DData)({
            fwhm: { x: this.fwhmX, y: this.fwhmY },
        }, options);
    }
    getFactor(volume = 1) {
        return (0, Gaussian_1.getGaussianFactor)(volume);
    }
    getVolume(height = (0, exports.calculateGaussian2DHeight)({
        fwhm: { x: this.fwhmX, y: this.fwhmY },
        volume: 1,
    })) {
        return (0, exports.getGaussian2DVolume)({
            fwhm: { x: this.fwhmX, y: this.fwhmY },
            height,
        });
    }
    widthToFWHM(width) {
        return (0, Gaussian_1.gaussianWidthToFWHM)(width);
    }
    fwhmToWidth(fwhm) {
        return (0, Gaussian_1.gaussianFwhmToWidth)(fwhm);
    }
    calculateHeight(volume = 1) {
        return (0, exports.calculateGaussian2DHeight)({
            volume,
            fwhm: { x: this.fwhmX, y: this.fwhmY },
        });
    }
    set fwhm(fwhm) {
        fwhm = ensureXYNumber(fwhm);
        this.fwhmX = fwhm.x;
        this.fwhmY = fwhm.y;
    }
}
exports.Gaussian2D = Gaussian2D;
const gaussian2DFct = (x, y, xFWHM, yFWHM) => {
    return Math.exp(constants_1.GAUSSIAN_EXP_FACTOR * (Math.pow(x / xFWHM, 2) + Math.pow(y / yFWHM, 2)));
};
exports.gaussian2DFct = gaussian2DFct;
const getGaussian2DData = (shape, options = {}) => {
    let { fwhm = 50, sd } = shape;
    fwhm = ensureFWHM2D(fwhm, sd);
    let { factor = (0, Gaussian_1.getGaussianFactor)(), length = { x: 0, y: 0 }, height = (0, exports.calculateGaussian2DHeight)({ fwhm, volume: 1 }), } = options;
    factor = ensureXYNumber(factor);
    length = ensureXYNumber(length);
    for (const axis of ['x', 'y']) {
        if (!length[axis]) {
            length[axis] = Math.min(Math.ceil(fwhm[axis] * factor[axis]), Math.pow(2, 25) - 1);
            if (length[axis] % 2 === 0)
                length[axis]++;
        }
    }
    const xCenter = (length.x - 1) / 2;
    const yCenter = (length.y - 1) / 2;
    const data = new Array(length.x);
    for (let i = 0; i < length.x; i++) {
        data[i] = new Float64Array(length.y);
    }
    for (let i = 0; i < length.x; i++) {
        for (let j = 0; j < length.y; j++) {
            data[i][j] =
                (0, exports.gaussian2DFct)(i - xCenter, j - yCenter, fwhm.x, fwhm.y) * height;
        }
    }
    return data;
};
exports.getGaussian2DData = getGaussian2DData;
const calculateGaussian2DHeight = (options = {}) => {
    let { volume = 1, fwhm = 50, sd } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    return (volume * Math.LN2 * 4) / (Math.PI * fwhm.y * fwhm.x);
};
exports.calculateGaussian2DHeight = calculateGaussian2DHeight;
const getGaussian2DVolume = (options = {}) => {
    let { fwhm = 50, height = 1, sd } = options;
    fwhm = ensureFWHM2D(fwhm, sd);
    return (height * Math.PI * fwhm.y * fwhm.x) / Math.LN2 / 4;
};
exports.getGaussian2DVolume = getGaussian2DVolume;
function ensureXYNumber(input) {
    return typeof input !== 'object' ? { x: input, y: input } : { ...input };
}
function ensureFWHM2D(fwhm, sd) {
    if (sd !== undefined) {
        let sdObject = ensureXYNumber(sd);
        return {
            x: (0, Gaussian_1.gaussianWidthToFWHM)(2 * sdObject.x),
            y: (0, Gaussian_1.gaussianWidthToFWHM)(2 * sdObject.y),
        };
    }
    else if (fwhm !== undefined) {
        return ensureXYNumber(fwhm);
    }
    else {
        throw new Error('ensureFWHM2D must have either fwhm or sd defined');
    }
}
//# sourceMappingURL=Gaussian2D.js.map