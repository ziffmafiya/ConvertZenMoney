"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGaussianData = exports.getGaussianFactor = exports.getGaussianArea = exports.gaussianFwhmToWidth = exports.gaussianWidthToFWHM = exports.gaussianFct = exports.calculateGaussianHeight = exports.Gaussian = void 0;
const constants_1 = require("../../../util/constants");
const erfinv_1 = __importDefault(require("../../../util/erfinv"));
class Gaussian {
    constructor(options = {}) {
        const { fwhm = 500, sd } = options;
        this.fwhm = sd ? gaussianWidthToFWHM(2 * sd) : fwhm;
    }
    fwhmToWidth(fwhm = this.fwhm) {
        return gaussianFwhmToWidth(fwhm);
    }
    widthToFWHM(width) {
        return gaussianWidthToFWHM(width);
    }
    fct(x) {
        return gaussianFct(x, this.fwhm);
    }
    getArea(height = calculateGaussianHeight({ fwhm: this.fwhm })) {
        return getGaussianArea({ fwhm: this.fwhm, height });
    }
    getFactor(area) {
        return getGaussianFactor(area);
    }
    getData(options = {}) {
        return getGaussianData(this, options);
    }
    calculateHeight(area = 1) {
        return calculateGaussianHeight({ fwhm: this.fwhm, area });
    }
    getParameters() {
        return ['fwhm'];
    }
}
exports.Gaussian = Gaussian;
function calculateGaussianHeight(options) {
    let { fwhm = 500, area = 1, sd } = options;
    if (sd)
        fwhm = gaussianWidthToFWHM(2 * sd);
    return (2 * area) / constants_1.ROOT_PI_OVER_LN2 / fwhm;
}
exports.calculateGaussianHeight = calculateGaussianHeight;
/**
 * Calculate the height of the gaussian function of a specific width (fwhm) at a speicifc
 * x position (the gaussian is centered on x=0)
 * @param x
 * @param fwhm
 * @returns y
 */
function gaussianFct(x, fwhm) {
    return Math.exp(constants_1.GAUSSIAN_EXP_FACTOR * Math.pow(x / fwhm, 2));
}
exports.gaussianFct = gaussianFct;
function gaussianWidthToFWHM(width) {
    return width * constants_1.ROOT_2LN2;
}
exports.gaussianWidthToFWHM = gaussianWidthToFWHM;
function gaussianFwhmToWidth(fwhm) {
    return fwhm / constants_1.ROOT_2LN2;
}
exports.gaussianFwhmToWidth = gaussianFwhmToWidth;
function getGaussianArea(options) {
    let { fwhm = 500, sd, height = 1 } = options;
    if (sd)
        fwhm = gaussianWidthToFWHM(2 * sd);
    return (height * constants_1.ROOT_PI_OVER_LN2 * fwhm) / 2;
}
exports.getGaussianArea = getGaussianArea;
function getGaussianFactor(area = 0.9999) {
    return Math.sqrt(2) * (0, erfinv_1.default)(area);
}
exports.getGaussianFactor = getGaussianFactor;
function getGaussianData(shape = {}, options = {}) {
    let { fwhm = 500, sd } = shape;
    if (sd)
        fwhm = gaussianWidthToFWHM(2 * sd);
    let { length, factor = getGaussianFactor(), height = calculateGaussianHeight({ fwhm }), } = options;
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = gaussianFct(i - center, fwhm) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
}
exports.getGaussianData = getGaussianData;
//# sourceMappingURL=Gaussian.js.map