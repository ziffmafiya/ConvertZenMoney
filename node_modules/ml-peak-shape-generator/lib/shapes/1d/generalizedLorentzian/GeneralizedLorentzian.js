"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGeneralizedLorentzianData = exports.getGeneralizedLorentzianFactor = exports.generalizedLorentzianFwhmToWidth = exports.generalizedLorentzianWidthToFWHM = exports.generalizedLorentzianFct = exports.getGeneralizedLorentzianArea = exports.calculateGeneralizedLorentzianHeight = exports.GeneralizedLorentzian = void 0;
const constants_1 = require("../../../util/constants");
/**
 * This shape is a linear combination of rational function (n|n+2), for n = 0 (lorentzian function) and n = 2
 * the parameter that combines those two functions is `gamma` and it is called the kurtosis parameter, it is an
 * implementation of generalized lorentzian shape published by Stanislav Sykora in the SMASH 2010. DOI:10.3247/SL3nmr10.006
 * @link http://www.ebyte.it/stan/Talk_ML_UserMeeting_SMASH_2010_GeneralizedLorentzian.html
 */
class GeneralizedLorentzian {
    constructor(options = {}) {
        const { fwhm = 500, gamma = 0.5 } = options;
        this.fwhm = fwhm;
        this.gamma = gamma;
    }
    fwhmToWidth(fwhm = this.fwhm) {
        return (0, exports.generalizedLorentzianFwhmToWidth)(fwhm);
    }
    widthToFWHM(width) {
        return (0, exports.generalizedLorentzianWidthToFWHM)(width);
    }
    fct(x) {
        return (0, exports.generalizedLorentzianFct)(x, this.fwhm, this.gamma);
    }
    getArea(height = 1) {
        return (0, exports.getGeneralizedLorentzianArea)({
            fwhm: this.fwhm,
            height,
            gamma: this.gamma,
        });
    }
    getFactor(area) {
        return (0, exports.getGeneralizedLorentzianFactor)(area);
    }
    getData(options = {}) {
        return (0, exports.getGeneralizedLorentzianData)(this, options);
    }
    calculateHeight(area = 1) {
        const { gamma, fwhm } = this;
        return (0, exports.calculateGeneralizedLorentzianHeight)({ fwhm, area, gamma });
    }
    getParameters() {
        return ['fwhm', 'gamma'];
    }
}
exports.GeneralizedLorentzian = GeneralizedLorentzian;
const calculateGeneralizedLorentzianHeight = ({ fwhm = 1, gamma = 1, area = 1, }) => {
    return (area / fwhm / (3.14159 - 0.420894 * gamma)) * 2;
};
exports.calculateGeneralizedLorentzianHeight = calculateGeneralizedLorentzianHeight;
/**
 * expression of integral generated by Mathematica of the function
 */
const getGeneralizedLorentzianArea = (options) => {
    const { fwhm = 500, height = 1, gamma = 1 } = options;
    return (height * fwhm * (3.14159 - 0.420894 * gamma)) / 2;
};
exports.getGeneralizedLorentzianArea = getGeneralizedLorentzianArea;
const generalizedLorentzianFct = (x, fwhm, gamma) => {
    const u = ((2 * x) / fwhm) ** 2;
    return (1 - gamma) / (1 + u) + (gamma * (1 + u / 2)) / (1 + u + u ** 2);
};
exports.generalizedLorentzianFct = generalizedLorentzianFct;
const generalizedLorentzianWidthToFWHM = (width) => {
    return width * constants_1.ROOT_THREE;
};
exports.generalizedLorentzianWidthToFWHM = generalizedLorentzianWidthToFWHM;
const generalizedLorentzianFwhmToWidth = (fwhm) => {
    return fwhm / constants_1.ROOT_THREE;
};
exports.generalizedLorentzianFwhmToWidth = generalizedLorentzianFwhmToWidth;
const getGeneralizedLorentzianFactor = (area = 0.9999) => {
    if (area >= 1) {
        throw new Error('area should be (0 - 1)');
    }
    const halfResidual = (1 - area) * 0.5;
    const quantileFunction = (p) => Math.tan(Math.PI * (p - 0.5));
    return ((quantileFunction(1 - halfResidual) - quantileFunction(halfResidual)) / 2);
};
exports.getGeneralizedLorentzianFactor = getGeneralizedLorentzianFactor;
const getGeneralizedLorentzianData = (shape = {}, options = {}) => {
    let { fwhm = 500, gamma = 1 } = shape;
    let { length, factor = (0, exports.getGeneralizedLorentzianFactor)(), height = (0, exports.calculateGeneralizedLorentzianHeight)({ fwhm, area: 1, gamma }), } = options;
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = (0, exports.generalizedLorentzianFct)(i - center, fwhm, gamma) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
};
exports.getGeneralizedLorentzianData = getGeneralizedLorentzianData;
//# sourceMappingURL=GeneralizedLorentzian.js.map