"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPseudoVoigtData = exports.getPseudoVoigtFactor = exports.getPseudoVoigtArea = exports.pseudoVoigtFwhmToWidth = exports.pseudoVoigtWidthToFWHM = exports.pseudoVoigtFct = exports.calculatePseudoVoigtHeight = exports.PseudoVoigt = void 0;
const constants_1 = require("../../../util/constants");
const Gaussian_1 = require("../gaussian/Gaussian");
const Lorentzian_1 = require("../lorentzian/Lorentzian");
class PseudoVoigt {
    constructor(options = {}) {
        const { fwhm = 500, mu = 0.5 } = options;
        this.mu = mu;
        this.fwhm = fwhm;
    }
    fwhmToWidth(fwhm = this.fwhm, mu = this.mu) {
        return (0, exports.pseudoVoigtFwhmToWidth)(fwhm, mu);
    }
    widthToFWHM(width, mu = this.mu) {
        return (0, exports.pseudoVoigtWidthToFWHM)(width, mu);
    }
    fct(x) {
        return (0, exports.pseudoVoigtFct)(x, this.fwhm, this.mu);
    }
    getArea(height = 1) {
        return (0, exports.getPseudoVoigtArea)({ fwhm: this.fwhm, height, mu: this.mu });
    }
    getFactor(area) {
        return (0, exports.getPseudoVoigtFactor)(area);
    }
    getData(options = {}) {
        const { length, factor, height = (0, exports.calculatePseudoVoigtHeight)({
            fwhm: this.fwhm,
            mu: this.mu,
            area: 1,
        }), } = options;
        return (0, exports.getPseudoVoigtData)(this, { factor, length, height });
    }
    calculateHeight(area = 1) {
        return (0, exports.calculatePseudoVoigtHeight)({ fwhm: this.fwhm, mu: this.mu, area });
    }
    getParameters() {
        return ['fwhm', 'mu'];
    }
}
exports.PseudoVoigt = PseudoVoigt;
const calculatePseudoVoigtHeight = (options = {}) => {
    let { fwhm = 1, mu = 0.5, area = 1 } = options;
    return (2 * area) / (fwhm * (mu * constants_1.ROOT_PI_OVER_LN2 + (1 - mu) * Math.PI));
};
exports.calculatePseudoVoigtHeight = calculatePseudoVoigtHeight;
const pseudoVoigtFct = (x, fwhm, mu) => {
    return (1 - mu) * (0, Lorentzian_1.lorentzianFct)(x, fwhm) + mu * (0, Gaussian_1.gaussianFct)(x, fwhm);
};
exports.pseudoVoigtFct = pseudoVoigtFct;
const pseudoVoigtWidthToFWHM = (width, mu = 0.5) => {
    return width * (mu * constants_1.ROOT_2LN2_MINUS_ONE + 1);
};
exports.pseudoVoigtWidthToFWHM = pseudoVoigtWidthToFWHM;
const pseudoVoigtFwhmToWidth = (fwhm, mu = 0.5) => {
    return fwhm / (mu * constants_1.ROOT_2LN2_MINUS_ONE + 1);
};
exports.pseudoVoigtFwhmToWidth = pseudoVoigtFwhmToWidth;
const getPseudoVoigtArea = (options) => {
    const { fwhm = 500, height = 1, mu = 0.5 } = options;
    return (fwhm * height * (mu * constants_1.ROOT_PI_OVER_LN2 + (1 - mu) * Math.PI)) / 2;
};
exports.getPseudoVoigtArea = getPseudoVoigtArea;
const getPseudoVoigtFactor = (area = 0.9999, mu = 0.5) => {
    return mu < 1 ? (0, Lorentzian_1.getLorentzianFactor)(area) : (0, Gaussian_1.getGaussianFactor)(area);
};
exports.getPseudoVoigtFactor = getPseudoVoigtFactor;
const getPseudoVoigtData = (shape = {}, options = {}) => {
    let { fwhm = 500, mu = 0.5 } = shape;
    let { length, factor = (0, exports.getPseudoVoigtFactor)(0.999, mu), height = (0, exports.calculatePseudoVoigtHeight)({ fwhm, mu, area: 1 }), } = options;
    if (!height) {
        height =
            1 /
                ((mu / Math.sqrt(-constants_1.GAUSSIAN_EXP_FACTOR / Math.PI)) * fwhm +
                    ((1 - mu) * fwhm * Math.PI) / 2);
    }
    if (!length) {
        length = Math.min(Math.ceil(fwhm * factor), Math.pow(2, 25) - 1);
        if (length % 2 === 0)
            length++;
    }
    const center = (length - 1) / 2;
    const data = new Float64Array(length);
    for (let i = 0; i <= center; i++) {
        data[i] = (0, exports.pseudoVoigtFct)(i - center, fwhm, mu) * height;
        data[length - 1 - i] = data[i];
    }
    return data;
};
exports.getPseudoVoigtData = getPseudoVoigtData;
//# sourceMappingURL=PseudoVoigt.js.map