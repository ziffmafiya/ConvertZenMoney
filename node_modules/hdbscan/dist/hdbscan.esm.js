import{kdTree}from"kd-tree-javascript";class HierarchyNode{constructor(e,t,r,s){this.parent=e,this.child=t,this.lambda=r,this.size=s}}class UnionFind{constructor(e){this.parent=new Array(2*(e-1)).fill(-1),this.nextLabel=e,this.size=new Array(e).fill(1).concat(new Array(e-1).fill(0))}union(e,t){this.size[this.nextLabel]=this.size[e]+this.size[t],this.parent[e]=this.nextLabel,this.parent[t]=this.nextLabel,this.size[this.nextLabel]=this.size[e]+this.size[t],this.nextLabel+=1}fastFind(e){for(var t=e;-1!=this.parent[e];)e=this.parent[e];for(;this.parent[t]!=e;)t=this.parent[t],this.parent[t]=e;return e}sizeOf(e){return this.size[e]}}class TreeUnionFind{constructor(e){this.data=new Array(e);for(var t=0;t<e;t++)this.data[t]=[t,0];this.isComponent=new Array(e).fill(!0)}union(e,t){e=this.find(e),t=this.find(t);this.data[e][1]<this.data[t][1]?this.data[e][0]=t:this.data[e][1]>this.data[t][1]?this.data[t][0]=e:(this.data[t][0]=e,this.data[e][1]+=1)}find(e){return this.data[e][0]!==e&&(this.data[e][0]=this.find(this.data[e][0]),this.isComponent[e]=!1),this.data[e][0]}components(){return[...Array(this.isComponent.length).keys()].filter(e=>this.isComponent[e])}}function bfsFromHierarchy(t,e){var r=t.length;const s=2*r-r+1;var n=[e];let i=[];for(;n.length;)i=i.concat(n),(n=n.filter(e=>e>=s).map(e=>e-s)).length&&(n=n.map(e=>[t[e].parent,t[e].child]).flat());return i}function condenseTree(e,t){var r=2*e.length,s=Math.floor(r/2)+1,n=s+1,i=new Array(1+r).fill(0);i[r]=s;var o=[],r=bfsFromHierarchy(e,r);console.log("bfs: ",r.length,r);const a=new Array(r.length).fill(!1);for(const u of r)if(!(a[u]||u<s)){var l=e[u-s],c=l.parent,h=l.child,d=0<l.lambda?1/l.lambda:1/0,f=s<=c?e[c-s].size:1,l=s<=h?e[h-s].size:1;if(t<=f&&t<=l)i[c]=n,n+=1,o.push(new HierarchyNode(i[u],i[c],d,f)),i[h]=n,n+=1,o.push(new HierarchyNode(i[u],i[h],d,l));else if(f<t&&l<t){for(const p of bfsFromHierarchy(e,c))p<s&&o.push(new HierarchyNode(i[u],p,d,1)),a[p]=!0;for(const m of bfsFromHierarchy(e,h))m<s&&o.push(new HierarchyNode(i[u],m,d,1)),a[m]=!0}else if(f<t){i[h]=i[u];for(const g of bfsFromHierarchy(e,c))g<s&&o.push(new HierarchyNode(i[u],g,d,1)),a[g]=!0}else{i[c]=i[u];for(const b of bfsFromHierarchy(e,h))b<s&&o.push(new HierarchyNode(i[u],b,d,1)),a[b]=!0}}return o}function computeStabilities(e){var t=Math.max(...e.map(e=>e.child)),r=Math.min(...e.map(e=>e.parent)),s=Math.max(...e.map(e=>e.parent))-r+1;t<r&&(t=r);const n=e.map(e=>[e.child,e.lambda]).sort((e,t)=>e[0]-t[0]),i=new Array(t+1).fill(NaN);for(var o=n.map(e=>e[0]),a=n.map(e=>e[1]),l=e.map(e=>e.parent),c=e.map(e=>e.size),h=e.map(e=>e.lambda),d=-1,f=0,u=0;u<n.length;u++)var p=o[u],m=a[u],f=p==d?Math.min(f,m):(d=(-1!=d&&(i[d]=f),p),m);-1!=d&&(i[d]=f),i[r]=0;const g=new Array(s).fill(0);for(var b=0;b<e.length;b++){var w=l[b],v=h[b],y=c[b];g[w-r]+=(v-i[w])*y}for(var M=new Map,b=0;b<g.length;b++)M.set(r+b,g[b]);return M}function bfsFromClusterTree(e,t){var r=[t];let s=[];for(;r.length;)s=s.concat(r),r=e.filter(e=>-1!==r.indexOf(e.parent)).map(e=>e.child);return s}function getClusterNodes(e,t,r="eom",s=!1,n=0,i=0){if("eom"!==r)throw Error("Only eom method is supported now.");if(0!==n)throw Error("epsilon selection is not supported now.");if(s)throw Error("singleCluster is not supported now.");n=s?[...t.keys()].sort((e,t)=>t-e):[...t.keys()].sort((e,t)=>t-e).slice(0,t.size-1);const o=e.filter(e=>1<e.size),a=new Map;n.forEach(e=>a.set(e,!0));s=e.filter(e=>1===e.size).map(e=>e.child),s=Math.max(...s)+1,e=Math.max(...e.map(e=>e.lambda));i<=0&&(i=s+1);const l=new Map;o.forEach(e=>l.set(e.child,e.size)),console.log("getClusters: ",a,s,e,l),console.log("nodeList: ",n),console.log("clusterTree: ",o);for(const p of n){const m=o.filter(e=>e.parent===p).map(e=>e.child);console.log("childSelection: ",p,m);var c=m.map(e=>t.get(e)||0).reduce((e,t)=>e+t,0);if(console.log("subtreeStability: ",p,c,t.get(p),l.get(p),i),c>(t.get(p)||0)||(l.get(p)||0)>i)a.set(p,!1),t.set(p,c);else for(const g of bfsFromClusterTree(o,p))g!==p&&a.set(g,!1)}console.log("isCluster: ",a,t);var h=[...a.entries()].filter(e=>e[1]).map(e=>e[0]).sort();const d=new Map,f=new Map;for(var u=0;u<h.length;u++)d.set(h[u],u),f.set(u,h[u]);return{clusterNodes:h,clusterNodesMap:d,revClusterNodesMap:f}}function labelClusters(e,t,r,s=!1,n=0,i=!1){if(0!==n)throw Error("epsilon selection is not supported now.");if(s)throw Error("singleCluster is not supported now.");if(i)throw Error("matchReferenceImplementation is not supported now.");var o=e.map(e=>e.parent),a=e.map(e=>e.child),l=Math.min(...o);const c=new Array(l);var h=Math.max(...o);const d=new TreeUnionFind(h+1);console.log("rootCluster: ",l);for(var f=0;f<e.length;f++){var u=a[f],p=o[f];-1===t.indexOf(u)&&d.union(p,u)}console.log("unionFind: ",d.components());for(var m,g,f=0;f<l;f++){const b=d.find(f);b<l?c[f]=-1:b===l?1===t.length&&s?(g=e.find(e=>e.child===f),0!==n?g&&g.lambda>=1/n?c[f]=r.get(b):c[f]=-1:(m=e.filter(e=>e.child===b).map(e=>e.lambda),g&&m&&g.lambda>=Math.max(...m)?c[f]=r.get(b):c[f]=-1)):c[f]=-1:i?(m=(g=e.find(e=>e.child===f))&&g.lambda,g=(g=e.find(e=>e.child===b))&&g.lambda,c[f]=m&&g&&g<m?r.get(b):-1):c[f]=r.get(b)}return c}function getClustersAndNoise(e){const t=[],r=[];for(var s=0;s<e.length;s++){var n=e[s];-1===n?r.push(s):(t[n]||(t[n]=[]),t[n].push(s))}return{clusters:t,noise:r}}function kdTreeCoreDistance(e,t,r){const s=new kdTree(e,r,[]);return e.map(e=>s.nearest(e,t)[0][1])}function buildMstUsingPrim(e,t,r,s){var n=e.length;const i=[],o=[],a=new Array(n).fill(1/0);for(var l,c=0,h=1/0,d=1/0,f=1/0,u=1;u<n;u++){i[c]=1;for(var p,m=s[c],d=1/0,h=0,g=0;g<n;g++)i[g]||(l=a[g],f=r(e[c],e[g]),1!=t&&(f/=t),p=s[g],l<m||l<p||l<f?l<d&&(d=l,h=g):(m<p?f<p&&(f=p):f<m&&(f=m),f<l?(a[g]=f)<d&&(d=f,h=g):l<d&&(d=l,h=g)));o[u-1]=new HierarchyNode(c,h,d,0),c=h}return o}function sortMst(e){return e.sort((e,t)=>e.lambda-t.lambda)}function createSingleLinkage(e){const t=new Array(e.length);for(var r=new UnionFind(e.length+1),s=0;s<e.length;++s){var n=e[s].parent,i=e[s].child,o=e[s].lambda,a=r.fastFind(n),n=r.fastFind(i),i=r.sizeOf(a)+r.sizeOf(n);t[s]=new HierarchyNode(a,n,o,i),r.union(a,n)}return t}function buildSingleLinkage(e,t=!1){var r=e;return t||(r=sortMst(e),console.log("sortedMst: ",r)),createSingleLinkage(r)}function kdTreePrim(e,t,r,s){t=kdTreeCoreDistance(e,t,s);console.log("coreDistances: ",t);t=buildMstUsingPrim(e,r,s,t);console.log("primMst: ",t);t=buildSingleLinkage(t);return console.log("singleLinkage: ",t),t}function euclidean(e,t){for(var r=0,s=0;s<e.length;s++)r+=Math.pow(e[s]-t[s],2);return Math.sqrt(r)}class Hdbscan{constructor(e,t=5,r=5,s=1,n=euclidean){this.input=e,this.minClusterSize=t,this.minSamples=r,this.alpha=s,this.metric=n;t=condenseTree(kdTreePrim(this.input,this.minSamples,this.alpha,this.metric),this.minClusterSize);console.log("condensedTree: ",t);r=computeStabilities(t);console.log("stabilityDict: ",r);var{clusterNodes:s,clusterNodesMap:n,revClusterNodesMap:r}=getClusterNodes(t,r);console.log("clusterNodes: ",s,"clusterNodesMap: ",n,"revClusterNodesMap: ",r);s=labelClusters(t,s,n);console.log("labeledInputs: ",s);var{clusters:n,noise:s}=getClustersAndNoise(s);console.log({clusters:n,noise:s}),this.clusters=n,this.noise=s}getClusters(){return this.clusters}getNoise(){return this.noise}}export{Hdbscan,euclidean};
