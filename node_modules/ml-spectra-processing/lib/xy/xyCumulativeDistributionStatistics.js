"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyCumulativeDistributionStatistics = xyCumulativeDistributionStatistics;
const x_1 = require("../x");
const xyCheck_1 = require("./xyCheck");
const xyMaxYPoint_1 = require("./xyMaxYPoint");
const STEPS = [0.25, 0.5, 0.75];
/**
 * Cumulative Distribution Statistics
 * @param data - array of points {x,y}
 * @returns x0, x25, x50, x75, x100, xMode, xMean (x for maxY)
 */
function xyCumulativeDistributionStatistics(data) {
    (0, xyCheck_1.xyCheck)(data, { minLength: 1 });
    const { x, y } = data;
    const cumulativeSum = (0, x_1.xCumulative)(y);
    const maxY = (0, x_1.xMaxValue)(cumulativeSum);
    for (let i = 0; i < cumulativeSum.length; i++) {
        cumulativeSum[i] /= maxY;
    }
    const result = {
        x0: 0,
        x25: 0,
        x50: 0,
        x75: 0,
        x100: 0,
        xMode: 0,
        xMean: 0,
    };
    // need to find the x values closest to STEPS/100
    result.x0 = x[0];
    result.x100 = x.at(-1);
    let currentStep = 0;
    breakPoint: for (let i = 1; i < cumulativeSum.length; i++) {
        while (STEPS[currentStep] < cumulativeSum[i]) {
            // Key is computed dynamically with a multiplication. This cannot be type-safe, hence the "as" assertion.
            const key = `x${STEPS[currentStep] * 100}`;
            result[key] =
                x[i - 1] +
                    (x[i] - x[i - 1]) *
                        ((STEPS[currentStep] - cumulativeSum[i - 1]) /
                            (cumulativeSum[i] - cumulativeSum[i - 1]));
            currentStep++;
            if (currentStep === STEPS.length)
                break breakPoint;
        }
    }
    result.xMode = (0, xyMaxYPoint_1.xyMaxYPoint)(data).x;
    let sumXY = 0;
    let sumY = 0;
    for (let i = 0; i < x.length; i++) {
        sumXY += x[i] * y[i];
        sumY += y[i];
    }
    result.xMean = sumXY / sumY;
    return result;
}
//# sourceMappingURL=xyCumulativeDistributionStatistics.js.map