"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyIntegral = xyIntegral;
const x_1 = require("../x");
const xyCheck_1 = require("./xyCheck");
/**
 * Generate a X / Y of the xyIntegral
 * @param data - Object that contains property x (an ordered increasing array) and y (an array)
 * @param options - Options
 * @returns - An object with the xyIntegration function
 */
function xyIntegral(data, options = {}) {
    const { reverse = false } = options;
    (0, xyCheck_1.xyCheck)(data, { minLength: 1 });
    const { x, y } = data;
    const { fromIndex, toIndex } = (0, x_1.xGetFromToIndex)(x, options);
    let xyIntegration = 0;
    const currentxyIntegral = {
        x: new Float64Array(toIndex - fromIndex + 1),
        y: new Float64Array(toIndex - fromIndex + 1),
    };
    let index = 0;
    if (reverse) {
        currentxyIntegral.y[index] = 0;
        currentxyIntegral.x[index++] = x[toIndex];
        for (let i = toIndex; i > fromIndex; i--) {
            xyIntegration += ((x[i] - x[i - 1]) * (y[i - 1] + y[i])) / 2;
            currentxyIntegral.x[index] = x[i - 1];
            currentxyIntegral.y[index++] = xyIntegration;
        }
        currentxyIntegral.x.reverse();
        currentxyIntegral.y.reverse();
    }
    else {
        currentxyIntegral.y[index] = 0;
        currentxyIntegral.x[index++] = x[fromIndex];
        for (let i = fromIndex; i < toIndex; i++) {
            xyIntegration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;
            currentxyIntegral.x[index] = x[i + 1];
            currentxyIntegral.y[index++] = xyIntegration;
        }
    }
    return currentxyIntegral;
}
//# sourceMappingURL=xyIntegral.js.map