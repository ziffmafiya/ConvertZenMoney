"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xyArrayAlign = xyArrayAlign;
const xy_1 = require("../xy");
const getSlots_1 = require("./utils/getSlots");
/**
 * Aligns data, can be used for spectra
 * @param data - data
 * @param options - Options
 */
function xyArrayAlign(data, options = {}) {
    const { delta = 1, requiredY = false } = options;
    data = data.map((spectrum) => (0, xy_1.xyJoinX)(spectrum, { delta }));
    const slots = (0, getSlots_1.getSlots)(data, { delta });
    const x = Float64Array.from(slots.map((slot) => slot.average));
    const ys = Array.from(data, () => new Float64Array(x.length));
    const positions = new Uint32Array(data.length);
    for (let i = 0; i < slots.length; i++) {
        const slot = slots[i];
        for (let j = 0; j < data.length; j++) {
            const spectrum = data[j];
            while (positions[j] < spectrum.x.length &&
                spectrum.x[positions[j]] <= slot.to) {
                ys[j][i] += spectrum.y[positions[j]];
                positions[j]++;
            }
        }
    }
    if (requiredY)
        return filterRequiredY(x, ys);
    return { x, ys };
}
function filterRequiredY(x, ys) {
    const newX = [];
    const newYs = Array.from(ys, () => []);
    for (let i = 0; i < x.length; i++) {
        if (ys.every((y) => y[i] !== 0)) {
            newX.push(x[i]);
            for (let j = 0; j < ys.length; j++) {
                newYs[j].push(ys[j][i]);
            }
        }
    }
    return { x: newX, ys: newYs };
}
//# sourceMappingURL=xyArrayAlign.js.map