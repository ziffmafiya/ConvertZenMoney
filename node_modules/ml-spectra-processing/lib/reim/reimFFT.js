"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reimFFT = reimFFT;
const fft_js_1 = __importDefault(require("fft.js"));
const x_1 = require("../x");
/**
 * ReimFFT.
 * @param data - complex spectrum
 * @param options - options.
 * @returns FFT of complex spectrum.
 */
function reimFFT(data, options = {}) {
    const { inverse = false, applyZeroShift = false } = options;
    const { re, im } = data;
    const size = re.length;
    const csize = size << 1;
    let complexArray = new Float64Array(csize);
    for (let i = 0; i < csize; i += 2) {
        complexArray[i] = re[i >>> 1];
        complexArray[i + 1] = im[i >>> 1];
    }
    const fft = new fft_js_1.default(size);
    let output = new Float64Array(csize);
    if (inverse) {
        if (applyZeroShift)
            complexArray = zeroShift(complexArray, true);
        fft.inverseTransform(output, complexArray);
    }
    else {
        fft.transform(output, complexArray);
        if (applyZeroShift)
            output = zeroShift(output);
    }
    const newRe = new Float64Array(size);
    const newIm = new Float64Array(size);
    for (let i = 0; i < csize; i += 2) {
        newRe[i >>> 1] = output[i];
        newIm[i >>> 1] = output[i + 1];
    }
    return { re: newRe, im: newIm };
}
function zeroShift(data, inverse) {
    const middle = inverse
        ? Math.ceil(data.length / 2)
        : Math.floor(data.length / 2);
    return (0, x_1.xRotate)(data, middle);
}
//# sourceMappingURL=reimFFT.js.map