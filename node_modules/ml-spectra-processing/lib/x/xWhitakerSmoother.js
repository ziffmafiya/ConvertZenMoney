"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xWhitakerSmoother = xWhitakerSmoother;
const matrixCholeskySolver_1 = require("../matrix/matrixCholeskySolver");
const addWeights_1 = require("../utils/addWeights");
const calculateAdaptiveWeights_1 = require("../utils/calculateAdaptiveWeights");
const createSystemMatrix_1 = require("../utils/createSystemMatrix");
const xEnsureFloat64_1 = require("./xEnsureFloat64");
const xMultiply_1 = require("./xMultiply");
/**
 * Computes the baseline points for the given data using an iterative smoothing algorithm.
 * @param yData - The input data array.
 * @param options - The options for baseline computation.
 * @returns - The computed baseline points.
 */
function xWhitakerSmoother(yData, options = {}) {
    const { lambda = 100, maxIterations = 100, tolerance = 1e-6, factorStd = 3, learningRate = 0.5, minWeight = 0.01, } = options;
    const size = yData.length;
    // eslint-disable-next-line prefer-const
    let { controlPoints, weights } = getWeightsAndControlPoints(yData, options);
    const prevBaseline = new Float64Array(size);
    let iteration = 0;
    let delta = Infinity;
    let baseline = yData.slice();
    const upperTriangularNonZeros = (0, createSystemMatrix_1.createSystemMatrix)(size, lambda);
    while (iteration < maxIterations && delta > tolerance) {
        const { leftHandSide, rightHandSide } = (0, addWeights_1.addWeights)(upperTriangularNonZeros, yData, weights);
        const cho = (0, matrixCholeskySolver_1.matrixCholeskySolver)(leftHandSide, size);
        if (!cho) {
            return baseline;
        }
        const newBaseline = cho(rightHandSide);
        weights = (0, calculateAdaptiveWeights_1.calculateAdaptiveWeights)(yData, newBaseline, weights, {
            controlPoints,
            minWeight,
            learningRate,
            factorStd,
        });
        delta = calculateDelta(newBaseline, prevBaseline, size);
        prevBaseline.set(newBaseline);
        baseline = (0, xEnsureFloat64_1.xEnsureFloat64)(newBaseline);
        iteration++;
    }
    return baseline;
}
/**
 * Calculates the delta between the current and previous baseline.
 * @param baseline - The current baseline array.
 * @param prevBaseline - The previous baseline array.
 * @param n - The length of the arrays.
 * @returns - The calculated delta value.
 */
function calculateDelta(baseline, prevBaseline, n) {
    let sum = 0;
    for (let i = 0; i < n; i++) {
        sum += (baseline[i] - prevBaseline[i]) ** 2;
    }
    return Math.sqrt(sum / n);
}
/**
 * Retrieves the control points and weights for the given data, the weights are modified multiplication of controlPoints if it exists.
 * @param  y - The input data array.
 * @param  options - The options for control points and weights.
 * @returns - The control points and modified weights.
 */
function getWeightsAndControlPoints(y, options = {}) {
    const { length } = y;
    const { controlPoints } = options;
    const { weights = Float64Array.from({ length }).fill(1) } = options;
    if (controlPoints && controlPoints.length !== y.length) {
        throw new RangeError('controlPoints should match the length with X');
    }
    else if (weights.length !== y.length) {
        throw new RangeError('weights should match the length with X');
    }
    return {
        weights: controlPoints ? (0, xMultiply_1.xMultiply)(weights, controlPoints) : weights,
        controlPoints,
    };
}
//# sourceMappingURL=xWhitakerSmoother.js.map