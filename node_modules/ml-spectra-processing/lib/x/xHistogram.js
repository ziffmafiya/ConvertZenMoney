"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xHistogram = xHistogram;
const utils_1 = require("../utils");
const xAbsolute_1 = require("./xAbsolute");
const xCheck_1 = require("./xCheck");
const xMaxValue_1 = require("./xMaxValue");
const xMinValue_1 = require("./xMinValue");
/**
 * Calculates a histogram of defined number of slots
 * @param array - Array containing values
 * @param options - options
 * @returns - result of the histogram
 */
function xHistogram(array, options = {}) {
    (0, xCheck_1.xCheck)(array);
    const histogram = options.histogram;
    const { centerX = true, nbSlots = histogram === undefined ? 256 : histogram.x.length, logBaseX, logBaseY, absolute = false, } = options;
    if (absolute) {
        array = (0, xAbsolute_1.xAbsolute)(array);
    }
    if (logBaseX) {
        array = array.slice();
        const logOfBase = Math.log10(logBaseX);
        for (let i = 0; i < array.length; i++) {
            array[i] = Math.log10(array[i]) / logOfBase;
        }
    }
    const { min = (0, xMinValue_1.xMinValue)(array), max = (0, xMaxValue_1.xMaxValue)(array) } = options;
    const slotSize = (max - min) / (nbSlots + Number.EPSILON);
    const y = histogram === undefined ? new Float64Array(nbSlots) : histogram.y;
    const x = histogram === undefined
        ? Array.from((0, utils_1.createFromToArray)({
            from: min + (centerX ? slotSize / 2 : 0),
            to: max - (centerX ? slotSize / 2 : 0),
            length: nbSlots,
        }))
        : histogram.x;
    for (const element of array) {
        const index = Math.max(Math.min(Math.floor((element - min - Number.EPSILON) / slotSize), nbSlots - 1), 0);
        y[index]++;
    }
    if (logBaseY) {
        const logOfBase = Math.log10(logBaseY);
        for (let i = 0; i < y.length; i++) {
            y[i] = Math.log10(y[i] + 1) / logOfBase;
        }
    }
    return { x, y };
}
//# sourceMappingURL=xHistogram.js.map