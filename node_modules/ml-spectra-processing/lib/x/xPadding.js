"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xPadding = xPadding;
const xCheck_1 = require("./xCheck");
const xEnsureFloat64_1 = require("./xEnsureFloat64");
/**
 * This function pads an array
 *s
 * @param array - the array that will be padded
 * @param options - options
 */
function xPadding(array, options = {}) {
    const { size = 0, value = 0, algorithm } = options;
    (0, xCheck_1.xCheck)(array);
    if (!algorithm) {
        return (0, xEnsureFloat64_1.xEnsureFloat64)(array);
    }
    const result = new Float64Array(array.length + size * 2);
    for (let i = 0; i < array.length; i++) {
        result[i + size] = array[i];
    }
    const fromEnd = size + array.length;
    const toEnd = 2 * size + array.length;
    switch (algorithm) {
        case 'value':
            for (let i = 0; i < size; i++) {
                result[i] = value;
            }
            for (let i = fromEnd; i < toEnd; i++) {
                result[i] = value;
            }
            break;
        case 'duplicate':
            for (let i = 0; i < size; i++) {
                result[i] = array[0];
            }
            for (let i = fromEnd; i < toEnd; i++) {
                result[i] = array.at(-1);
            }
            break;
        case 'circular':
            for (let i = 0; i < size; i++) {
                result[i] =
                    array[(array.length - (size % array.length) + i) % array.length];
            }
            for (let i = 0; i < size; i++) {
                result[i + fromEnd] = array[i % array.length];
            }
            break;
        default:
            throw new Error(`unknown algorithm ${String(algorithm)}`);
    }
    return result;
}
//# sourceMappingURL=xPadding.js.map